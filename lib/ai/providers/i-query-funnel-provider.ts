import type { PlaceholdersSpec } from "@/lib/services/template-validator.service";
import type { ConversationMessage } from "@/lib/types/conversation";

export type QueryFunnelScope = "form" | "schema";

export interface TemplateExtractionRequest {
  questionText: string;
  sqlQuery: string;
  schemaContext?: string;
}

export interface TemplateExtractionDraft {
  name: string;
  intent: string;
  description: string;
  sqlPattern: string;
  placeholdersSpec: PlaceholdersSpec | null;
  keywords: string[];
  tags: string[];
  examples: string[];
}

export interface TemplateExtractionResponse {
  modelId: string;
  draft: TemplateExtractionDraft;
  warnings: string[];
}

export interface CompletionParams {
  system: string;
  userMessage: string;
  maxTokens?: number;
  temperature?: number;
}

export interface ConversationCompletionParams {
  conversationHistory: ConversationMessage[];
  currentQuestion: string;
  customerId: string;
  temperature?: number;
  maxTokens?: number;
}

/**
 * Request to generate sub-questions from a complex original question.
 */
export interface SubQuestionGenerationRequest {
  originalQuestion: string;
  formDefinition?: any;
  databaseSchemaContext?: string;
  assessmentFormVersionFk?: string; // Used for caching key when form scoped
  scope?: QueryFunnelScope;
}

/**
 * The structure of a single sub-question as generated by the AI.
 */
export interface GeneratedSubQuestion {
  questionText: string;
  order: number;
  // For future DAG support
  dependencies?: number[];
}

/**
 * The response from the AI provider for sub-question generation.
 */
export interface SubQuestionGenerationResponse {
  subQuestions: GeneratedSubQuestion[];
}

/**
 * Request to generate a SQL query for a single sub-question.
 */
export interface GenerateQueryRequest {
  subQuestion: string;
  previousQueries: string[];
  assessmentFormDefinition?: any;
  databaseSchemaContext?: string;
  desiredFields?: string[]; // Optional enrichment fields (entity.field)
  scope?: QueryFunnelScope;
  subQuestionId?: number;
}

/**
 * The response from the AI provider for SQL query generation.
 */
export interface GenerateQueryResponse {
  explanation: string;
  generatedSql: string;
  validationNotes: string;
  matchedQueryTemplate: string;
  // Enrichment fields (optional)
  fieldsApplied?: string[];
  joinSummary?: string;
  sqlWarnings?: string[];
  templateUsageId?: number;
}

/**
 * Request to generate chart recommendations based on SQL results.
 */
export interface GenerateChartRecommendationsRequest {
  sqlQuery: string;
  queryResults: any[];
  subQuestion: string;
  assessmentFormDefinition?: any;
  databaseSchemaContext?: string;
  scope?: QueryFunnelScope;
}

/**
 * The response from the AI provider for chart recommendations.
 */
export interface GenerateChartRecommendationsResponse {
  recommendedChartType: string;
  availableMappings: Record<string, any>;
  explanation: string;
  chartTitle: string;
}

/**
 * Defines the contract for an AI provider that can handle the query funnel workflow.
 * This allows for a pluggable architecture to support different AI models (e.g., Claude, Gemini).
 */
export interface IQueryFunnelProvider {
  /**
   * Breaks down a complex question into a series of simpler, sequential sub-questions.
   */
  generateSubQuestions(
    request: SubQuestionGenerationRequest
  ): Promise<SubQuestionGenerationResponse>;

  /**
   * Generates a SQL query for a given sub-question, considering the context of previous queries.
   */
  generateQuery(request: GenerateQueryRequest): Promise<GenerateQueryResponse>;

  /**
   * Generates chart recommendations based on SQL query results.
   */
  generateChartRecommendations(
    request: GenerateChartRecommendationsRequest
  ): Promise<GenerateChartRecommendationsResponse>;

  /**
   * Extracts a reusable template definition from a successful question + SQL pair.
   */
  extractTemplateDraft(
    request: TemplateExtractionRequest
  ): Promise<TemplateExtractionResponse>;

  /**
   * General-purpose LLM completion method for flexible prompting.
   * Used by intent classifier, ambiguity detection, and other services.
   */
  complete(options: CompletionParams): Promise<string>;

  /**
   * Conversation-aware completion with caching and context.
   */
  completeWithConversation(
    request: ConversationCompletionParams
  ): Promise<string>;

  /**
   * Build conversation history prompt.
   */
  buildConversationHistory(messages: ConversationMessage[]): string;
}
