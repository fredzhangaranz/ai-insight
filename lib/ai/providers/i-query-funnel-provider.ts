/**
 * Request to generate sub-questions from a complex original question.
 */
export interface SubQuestionGenerationRequest {
  originalQuestion: string;
  formDefinition: any;
  databaseSchemaContext: string;
  assessmentFormVersionFk: string; // Used for caching key
}

/**
 * The structure of a single sub-question as generated by the AI.
 */
export interface GeneratedSubQuestion {
  questionText: string;
  order: number;
  // For future DAG support
  dependencies?: number[];
}

/**
 * The response from the AI provider for sub-question generation.
 */
export interface SubQuestionGenerationResponse {
  subQuestions: GeneratedSubQuestion[];
}

/**
 * Request to generate a SQL query for a single sub-question.
 */
export interface GenerateQueryRequest {
  subQuestion: string;
  previousQueries: string[];
  assessmentFormDefinition: any;
  databaseSchemaContext: string;
  desiredFields?: string[]; // Optional enrichment fields (entity.field)
}

/**
 * The response from the AI provider for SQL query generation.
 */
export interface GenerateQueryResponse {
  explanation: string;
  generatedSql: string;
  validationNotes: string;
  matchedQueryTemplate: string;
  // Enrichment fields (optional)
  fieldsApplied?: string[];
  joinSummary?: string;
  sqlWarnings?: string[];
}

/**
 * Request to generate chart recommendations based on SQL results.
 */
export interface GenerateChartRecommendationsRequest {
  sqlQuery: string;
  queryResults: any[];
  subQuestion: string;
  assessmentFormDefinition: any;
}

/**
 * The response from the AI provider for chart recommendations.
 */
export interface GenerateChartRecommendationsResponse {
  recommendedChartType: string;
  availableMappings: Record<string, any>;
  explanation: string;
  chartTitle: string;
}

/**
 * Defines the contract for an AI provider that can handle the query funnel workflow.
 * This allows for a pluggable architecture to support different AI models (e.g., Claude, Gemini).
 */
export interface IQueryFunnelProvider {
  /**
   * Breaks down a complex question into a series of simpler, sequential sub-questions.
   */
  generateSubQuestions(
    request: SubQuestionGenerationRequest
  ): Promise<SubQuestionGenerationResponse>;

  /**
   * Generates a SQL query for a given sub-question, considering the context of previous queries.
   */
  generateQuery(request: GenerateQueryRequest): Promise<GenerateQueryResponse>;

  /**
   * Generates chart recommendations based on SQL query results.
   */
  generateChartRecommendations(
    request: GenerateChartRecommendationsRequest
  ): Promise<GenerateChartRecommendationsResponse>;
}
