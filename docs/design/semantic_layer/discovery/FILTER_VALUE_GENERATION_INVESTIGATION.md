# Investigation: Filter Value Generation in Intent Classification
## Discovery Report: Where "simple_bandage" Comes From

**Date:** November 12, 2025  
**Question:** How many patients have simple bandage?  
**Issue:** Generated value is `"simple_bandage"` but actual database value is `"Simple Bandage"`  
**Status:** Investigation Complete ✅

---

## Executive Summary

The value `"simple_bandage"` is **generated by the LLM (Gemini/Claude) in the intent classification step**, not retrieved from the database. The system currently has a **3-phase gap**:

1. **Phase 1 (Intent Classification):** LLM generates filter values like `"simple_bandage"` based on user input transformation
2. **Phase 2 (Terminology Mapping):** Never executes because the filter already has a `value` field
3. **Phase 3 (Database Query):** Uses the incorrect generated value instead of actual stored value

---

## Deep Dive: Where "simple_bandage" Originates

### 1. User Input → LLM Generation

**Flow:**
```
User Input: "How many patients have simple bandage?"
    ↓
[Intent Classification - llm calls LLM]
    ↓
LLM Response: {
  "filters": [{
    "concept": "treatment_type",
    "userTerm": "simple bandage",    ← User's exact phrase
    "value": "simple_bandage"         ← LLM-GENERATED snake_case version
  }]
}
```

**Key File:** `lib/prompts/intent-classification.prompt.ts` (line 125-127)

The system prompt provides this example:
```typescript
"Input: 'What is the average healing rate for diabetic wounds in the last 6 months?'
Output: {
  ...
  filters: [{
    concept: 'wound_classification',
    userTerm: 'diabetic wounds',
    value: 'DFU'  ← Example shows abbreviated/normalized value
  }]
  ...
}"
```

### 2. Why LLM Generates `"simple_bandage"` Instead of `"Simple Bandage"`

**Root Cause:** The intent classification prompt does NOT provide clear guidance on how to generate the `value` field.

**Current Guidance (lines 90-93):**
```
"2. **Identify Filters**: Find references to data constraints
   - Match against filter categories listed above
   - Preserve the user's exact phrasing in "userTerm"
   - Provide semantic category in "concept""
```

**Critical Missing Information:**
- ❌ No instruction on what format the `value` should be
- ❌ No examples showing actual database values
- ❌ No guidance on case normalization (should it be lowercase? snake_case? Title Case?)
- ❌ No reference to the `SemanticIndexOption` table that contains real values

**What LLM does instead:**
The LLM applies a reasonable heuristic: converts user input to a "normalized" form:
- "simple bandage" → lowercase → "simple bandage" → replace spaces with underscore → "simple_bandage"

This is a **reasonable guess but incorrect** because the actual database stores "Simple Bandage" as-is.

---

## What's Actually Stored in the Database

### SemanticIndexOption Table

**Structure:**
```sql
CREATE TABLE "SemanticIndexOption" (
  id UUID PRIMARY KEY,
  semantic_index_field_id UUID NOT NULL,
  option_value TEXT NOT NULL,        ← This is what's stored
  option_code TEXT,
  semantic_category VARCHAR(255),
  confidence NUMERIC(5,2),
  metadata JSONB
);
```

**Where data comes from:**
- **Source:** `dbo.AttributeLookup` table in customer's SQL Server database
- **Populated by:** `form-discovery.service.ts` (lines 600-615)
- **Query:**
```sql
SELECT 
  id,
  [text] as text,      ← This becomes option_value
  [code] as code
FROM dbo.AttributeLookup
WHERE attributeTypeFk = @fieldId AND isDeleted = 0
```

**What's stored for "simple bandage" in Silhouette:**
```
option_value: "Simple Bandage"    ← Exactly as configured in Silhouette
option_code: "SB001"              ← Or whatever code exists
semantic_category: (matched via embedding)
confidence: (0.0-1.0 confidence score)
```

### Where the Value Is Supposed to Be Used

In the SQL generation phase, the correct flow should be:
```sql
SELECT COUNT(DISTINCT P.id) AS NumberOfPatientsWithSimpleBandage
FROM rpt.Patient AS P
JOIN rpt.Note AS N ON P.id = N.patientFk
JOIN rpt.AttributeType AS AT ON N.attributeTypeFk = AT.id
WHERE AT.name = 'Treatment Applied'
  AND N.value = 'Simple Bandage'     ← Should use ACTUAL stored value
```

But currently uses:
```sql
WHERE AT.name = 'Treatment Applied'
  AND N.value = 'simple_bandage'     ← LLM's guess, not actual value
```

---

## The Three-Phase Gap: Why Terminology Mapping Doesn't Run

### Current Architecture

```
User Input: "simple bandage"
    ↓
┌─────────────────────────────────┐
│ PHASE 1: Intent Classification  │  ✅ Runs always
│ → Generates filter.value        │  Produces: "simple_bandage"
└─────────────────────────────────┘
    ↓
┌─────────────────────────────────┐
│ PHASE 2: Terminology Mapping    │  ❌ Skipped if filter has value
│ → Would map term to real value   │  
└─────────────────────────────────┘
    ↓
┌─────────────────────────────────┐
│ PHASE 3: Context Discovery      │  Uses filter.value as-is
│ → Uses intent filters directly   │
└─────────────────────────────────┘
```

### Code Evidence

**Intent Filter Type** (`lib/services/context-discovery/types.ts`, lines 57-61):
```typescript
export interface IntentFilter {
  concept: string;
  userTerm: string;
  value?: string;  // Optional - but LLM always generates it
}
```

**Context Discovery Process** (`lib/services/context-discovery/context-discovery.service.ts`, lines 497-522):
```typescript
private extractUserTerms(intentResult: any): string[] {
  const terms = new Set<string>();
  
  // Extract from filters
  if (Array.isArray(intentResult.filters)) {
    for (const filter of intentResult.filters) {
      if (filter.userTerm) {
        terms.add(filter.userTerm);  // Extracts "simple bandage" for mapping
      }
      if (filter.value) {
        terms.add(filter.value);     // ALSO extracts "simple_bandage"
      }
    }
  }
  return Array.from(terms);  // Returns ["simple bandage", "simple_bandage"]
}
```

**Terminology Mapper doesn't get called for the value** because the intent already populated `filter.value`. The mapper is designed to **enrich** filters that don't have values, but here the LLM already provided one (even if incorrect).

---

## What SHOULD Be Stored vs. What IS Stored

### In SemanticIndexOption (PostgreSQL - InsightGen)

This table is **correctly populated** by form discovery:

```
Query to Silhouette:
  SELECT [text] as text, [code] as code 
  FROM dbo.AttributeLookup
  WHERE attributeTypeFk = (treatment applied field id)

Results:
  id=1, text="Simple Bandage", code="SB001"
  id=2, text="Complex Dressing", code="CD001"
  id=3, text="Negative Pressure Therapy", code="NPT001"

Stored in SemanticIndexOption:
  option_value: "Simple Bandage" ✅ Exact value
  option_code: "SB001"
  semantic_category: "treatment_type" (via embedding match)
```

### The Mismatch

| Phase | What's Used | Actual Value | Stored Value | Status |
|-------|------------|--------------|-------------|--------|
| Intent Classification (LLM) | Generated/guessed | `simple_bandage` | `Simple Bandage` | ❌ WRONG |
| SQL Generation | Filter value | `simple_bandage` | `Simple Bandage` | ❌ WRONG |
| Database Query | WHERE clause | `'simple_bandage'` | `'Simple Bandage'` | ❌ NO MATCH |

---

## How Terminology Mapper Works (If Called)

**File:** `lib/services/context-discovery/terminology-mapper.service.ts`

**Process:**
```
User Term: "simple bandage"
    ↓
1. Normalize: "simple bandage" → "simple bandage" (lowercase, remove special chars)
    ↓
2. Expand abbreviations: (no matches for "simple bandage")
    ↓
3. Search SemanticIndexOption:
    - Patterns: ["%simple bandage%", "%simple%", "%bandage%"]
    - Query: ILIKE pattern match against option_value
    ↓
4. Match Found: "Simple Bandage"
    ↓
5. Calculate similarity score (0.95+)
    ↓
6. Return: {
     userTerm: "simple bandage",
     fieldValue: "Simple Bandage",  ← Correct value!
     semanticConcept: "treatment_type",
     confidence: 0.95
   }
```

**Key Method:** `normalizeTerm()` (lines 422-434)
```typescript
private normalizeTerm(value: string): string {
  if (!value) return "";
  const collapsed = value
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")      // Remove accents
    .replace(/[^a-zA-Z0-9\s]/g, " ")      // Remove special chars
    .toLowerCase()                         // To lowercase
    .split(/\s+/)
    .filter(Boolean)
    .map((token) => this.singularize(token));  // Singularize
  
  return collapsed.join(" ").trim();  // Return space-joined, not underscores!
}
```

**Important:** The mapper normalizes to **space-separated**, not snake_case!

---

## Why This Happens: Root Cause Analysis

### 1. LLM's Reasoning Process

When the LLM sees "simple bandage" and needs to generate a `value`:
- No guidance on format → applies common convention
- Web data patterns show lowercase+underscore for codes
- Produces: "simple_bandage"

### 2. Design Gap in Intent Classification

The prompt examples show:
```
userTerm: "diabetic wounds"  →  value: "DFU"      (abbreviated)
userTerm: "arterial wounds"  →  value: "arterial_ulcer"  (snake_case)
```

This suggests to the LLM: **"Generate a semantic code version"**

But the actual system expects: **"Leave this empty or make a guess we'll fix later"**

### 3. Missing Integration Point

The intent classification **should either:**

**Option A (Current Design):** 
- Don't generate `value` in intent classification
- Let terminology mapper do it (populate from SemanticIndexOption)

**Option B (Alternative):**
- Provide ontology context to LLM
- Teach it exact codes from `ClinicalOntology`
- More accurate but more complex

### 4. Silhouette Data Format Issue

The actual form option values are **Title Case** (e.g., "Simple Bandage") because:
- Entered by users in Silhouette UI
- Designed for human readability
- Not normalized to snake_case on storage

---

## What Data IS Correctly Stored

### Form Metadata (SemanticIndex + SemanticIndexField) ✅

```sql
SELECT * FROM "SemanticIndex" WHERE form_identifier = 'TreatmentForm';
-- form_name: "Treatment Assessment"
-- form_type: 7
-- field_count: 12
-- avg_confidence: 0.92

SELECT * FROM "SemanticIndexField" 
WHERE semantic_index_id = (above) AND attribute_type_id = 456;
-- field_name: "Treatment Applied"
-- data_type: "SingleSelect"
-- semantic_concept: "treatment_type"
-- confidence: 0.94
-- metadata: {"variableName": "TreatmentApplied", "attributeTypeId": 456}
```

### Field Options (SemanticIndexOption) ✅

```sql
SELECT * FROM "SemanticIndexOption" 
WHERE semantic_index_field_id = (above)
ORDER BY option_value;

-- option_value: "Complex Dressing" | option_code: "CD" | confidence: 0.92
-- option_value: "Negative Pressure Therapy" | option_code: "NPT" | confidence: 0.94
-- option_value: "Simple Bandage" | option_code: "SB" | confidence: 0.96
```

**✅ This is correct.** The database stores exact values from Silhouette.

---

## Summary: The Information Flow

```
┌─────────────────────────────────────────────────────────────┐
│ USER ASKS: "How many patients have simple bandage?"        │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ INTENT CLASSIFIER (LLM) [PHASE 1]                           │
│ • Input: question                                           │
│ • Available context: Clinical ontology (not form options!)  │
│ • Decision: Must generate filter.value                      │
│ • Output: value = "simple_bandage" (LLM's guess) ❌         │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ CONTEXT DISCOVERY [PHASE 2]                                 │
│ • Extract terms: ["simple bandage", "simple_bandage"]      │
│ • Call TerminologyMapper.mapUserTerms()                     │
│ • Mapper searches SemanticIndexOption                       │
│ • ✅ Finds: "Simple Bandage" (actual database value)        │
│ • But filter.value already populated, not overwritten!      │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ SQL GENERATION [PHASE 3]                                    │
│ • Uses filter.value = "simple_bandage" (from LLM)          │
│ • Generates: WHERE N.value = 'simple_bandage' ❌            │
│ • Should use: WHERE N.value = 'Simple Bandage' ✅           │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ DATABASE QUERY RESULT: 0 rows (no match) ❌                  │
│ Correct result would be: N rows (with the right value)      │
└─────────────────────────────────────────────────────────────┘
```

---

## Key Findings

| Finding | Status | Impact |
|---------|--------|--------|
| **SemanticIndexOption has correct values** | ✅ Verified | Data is good; problem is usage |
| **Terminology mapper can find correct values** | ✅ Verified | Logic works; just not invoked for intent filters |
| **Intent classifier generates incorrect values** | ❌ Confirmed | LLM guesses at format/value |
| **Filter value is pre-populated by LLM** | ⚠️ Design issue | Blocks terminology mapping enhancement |
| **Form discovery correctly populates options** | ✅ Verified | No bugs in form-discovery service |
| **Case sensitivity in database** | ✅ Confirmed | Database stores exact Silhouette values |

---

## Recommendations for Investigation

### 1. **Verify Assumptions**
```sql
-- Check what's ACTUALLY stored for treatment options
SELECT 
  option_value,
  option_code,
  semantic_category,
  confidence
FROM "SemanticIndexOption" sio
JOIN "SemanticIndexField" sif ON sio.semantic_index_field_id = sif.id
WHERE sif.field_name ILIKE '%treatment%'
  AND sif.semantic_concept = 'treatment_type'
ORDER BY sio.option_value;
```

### 2. **Check Real Patient Data**
```sql
-- What values are actually in rpt.Note for treatment?
SELECT DISTINCT 
  N.value,
  COUNT(*) as count
FROM rpt.Note N
JOIN rpt.AttributeType AT ON N.attributeTypeFk = AT.id
WHERE AT.name = 'Treatment Applied'
GROUP BY N.value
ORDER BY count DESC;
```

### 3. **Review LLM Intent Output**
```typescript
// Add logging to see what LLM actually generates
console.log("LLM filter values:", intent.filters.map(f => f.value));
```

### 4. **Check Terminology Mapping Results**
```typescript
// What does terminology mapper find for "simple bandage"?
const mapper = getTerminologyMapperService();
const results = await mapper.mapUserTerms(
  ["simple bandage"],
  customerId
);
console.log("Terminology mapping results:", results);
```

---

## Conclusion

The value **"simple_bandage"** originates from **LLM's interpretation of the user input** during intent classification, not from the database. The system has the correct data (in SemanticIndexOption) and the correct mapping logic (TerminologyMapper), but they don't work together properly because:

1. **Intent Classifier generates a guess** instead of leaving it empty
2. **Terminology Mapper is designed to enrich, not override** pre-populated values
3. **No validation layer** checks if generated values actually exist in the semantic database

The fix requires either:
- **Design Change:** Don't populate `filter.value` in intent classification; let terminology mapper do it
- **Enhancement:** Cross-reference generated values against SemanticIndexOption before using them
- **LLM Prompt Improvement:** Provide form option context to LLM so it can generate accurate values


